#!/usr/bin/env bash

# This https://stackoverflow.com/questions/14001825/how-to-check-if-a-certain-port-is-open-and-unused
# says nc -z can test if a port is used

# Based on  https://superuser.com/questions/315523/ssh-connection-between-two-behind-nat-computers-through-third-public-ip-computer

# need systemd service: https://unix.stackexchange.com/questions/166473/debian-how-to-run-a-script-on-startup-as-soon-as-there-is-an-internet-connecti

set -o errexit
set -o nounset
set -o pipefail
export SHELLOPTS

trap exit INT

function ERR_trap ()
{
    echo "Error exit at line: ${1}, status value: ${2}!"
    exit ${2}
}
set -o errtrace
trap 'ERR_trap ${LINENO} ${?}' ERR


# Kill background process that is created in "connection_setup":
local_ssh_pid=''
function EXIT_trap ()
{
    if [[ ! -z "${local_ssh_pid}" ]] ; then
	kill ${local_ssh_pid}
    fi
}
trap 'EXIT_trap' EXIT


# Directory for 3dpssh config and tracking files.  This is used on
# both the local and 3d party machines.
_3dpssh_dir=.3dps

# First port to use for local connection.
#
# Note that if this port is in use, we search for an unused one one.
# Because this port is on 127.0.0.1 only, this is not likely to
# interfear with anything.
local_port=22222


# Check to see if we have done a setup on the local machine:
if [[ ! -d ${HOME}/${_3dpssh_dir} ]] ; then
    echo -n "It appears that 3dpssh is not configured.  Would you like to configure it now? "
    read answer
    if [[ "${answer}" != 'y' ]] ; then
	echo "Not configuring..."
	exit
    fi

    echo -n "3d party host: "
    read _3dpssh_host
    echo -n "local name: "
    read _3dpssh_local_name

    mkdir -p ${HOME}/${_3dpssh_dir}
    cat <<-EOF > ${HOME}/${_3dpssh_dir}/.config
	_3dpssh_host="${_3dpssh_host}"
	_3dpssh_local_name="${_3dpssh_local_name}"
EOF
fi

source ${HOME}/${_3dpssh_dir}/.config


# Should test for ping


#REMOTE_HOME="$(ssh ${_3dpssh_host} echo \${HOME})"



eval "
function check_3d_party_setup_helper ()
{
    local i

    # Create working directory (_3dpssh_dir) if necessary
    if [[ ! -d \${HOME}/${_3dpssh_dir} ]] ; then
    	mkdir -p \${HOME}/${_3dpssh_dir}
    fi

    # Prune dead connections
    for i in \${HOME}/${_3dpssh_dir}/* ; do	    
    	if ! grep -q \${i} /proc/net/unix ; then
    	    rm -f \${i}
    	fi
    done

    # Return a list of live connections
    echo \${HOME} \${HOME}/${_3dpssh_dir}/*
}    
"
#declare -f check_3d_party_setup_helper

# get_remote_home_and_connection_list sets the following two variables:
CONNECTION_LIST=''
REMOTE_HOME=''
function get_remote_home_and_connection_list ()
{
    local list i first

    list=$( \
	    ssh ${_3dpssh_host} \
		"$(declare -f check_3d_party_setup_helper) ; check_3d_party_setup_helper" \
	)

    CONNECTION_LIST=''
    first=true
    for i in ${list} ; do
	if ${first} ; then
	    REMOTE_HOME=${i}
	    first=false
	else
	    CONNECTION_LIST="${CONNECTION_LIST} ${i}"
	fi
    done
}

function check_3d_party_setup ()
{
    local i found

    get_remote_home_and_connection_list
    
    found=false
    for i in ${CONNECTION_LIST} ; do
	if [[ "$(basename "${i}")" == "${_3dpssh_local_name}" ]] ; then
	    found=true
	fi
    done
    
    if ! ${found} ; then
	echo "Backend connection not found, starting it..."

	pkill -f "ssh -fAXN -R " || :
	ssh -fAXN -R ${REMOTE_HOME}/${_3dpssh_dir}/${_3dpssh_local_name}:127.0.0.1:22 ${_3dpssh_host}

	get_remote_home_and_connection_list
    
	found=false
	for i in ${CONNECTION_LIST} ; do
	    if [[ "$(basename "${i}")" == "${_3dpssh_local_name}" ]] ; then
		found=true
	    fi
	done

	# if not found after start, somethings broken
	if ! ${found} ; then
	    echo "Starting backend connection failed.  Sum Ting Wong"
	    exit 1
	fi
    fi
}


function list_available_connections ()
{
    local i
    
    echo -e "Available Connections:"
    for i in ${CONNECTION_LIST} ; do
	echo -e "\t$(basename ${i})"
    done
}


function connection_setup ()
{
    # "nc -z" can be used to test if a port is busy

    # Search for an available port:
    while nc -z 127.0.0.1 ${local_port} ; do
	local_port=$((local_port + 1))
    done

    # --> race condition here on local_port <-- 

    ssh -AXN -L 127.0.0.1:${local_port}:${REMOTE_HOME}/${_3dpssh_dir}/${1} ${_3dpssh_host} &
    # --> race condition here on local_ssh_pid <--
    local_ssh_pid=${!}

    # Wait for the above connection to complete.  A "spinner".
    # --> potential infinite loop <--
    i=0
    echo -n "Connecting "
    while ! nc -z 127.0.0.1 ${local_port} ; do
	case ${i} in
	    ( 0 ) echo -ne '-\b' 
	    ;;
	    ( 1 ) echo -ne '\\\b' 
	    ;;
	    ( 2 ) echo -ne '|\b'
	    ;;
	    ( 3 ) echo -ne '/\b'
	    ;;
	    ( * ) echo 'sum ting wong'
	    exit 1
	    ;;
	esac
        i=$(( (i+1) % 4 ))
	sleep 0.2
    done
    echo -en "\r"

    # Note: the "ssh -AXN -L ..." created in here will be terminated
    # in the EXIT_trap function.
    #
    # Thus a 
    #     kill ${local_ssh_pid}
    # is not needed.
}    


function do_ssh ()
{
    connection_setup ${1}
    
    ssh \
	-o GlobalKnownHostsFile=/dev/null \
	-o UserKnownHostsFile=/dev/null \
	-o StrictHostKeyChecking=no \
	-p ${local_port} \
	127.0.0.1
}


function do_connection_environment ()
{
    connection_setup ${1}

    echo "For ssh/scp/rsync/sshfs, use \"localhost\" for ${1}."
    echo "You are now in a sub-shell ... ^D to exit"

    export -n SHELLOPTS
    bash --rcfile <(echo \
			". ~/.bashrc;" \
			"PS1=\"[localhost-->${1}] \${PS1}\";" \
			"alias rsync=\"rsync -e 'ssh -p ${local_port}'\";" \
			"alias ssh=\"ssh" \
			    "-o GlobalKnownHostsFile=/dev/null" \
			    "-o UserKnownHostsFile=/dev/null" \
			    "-o StrictHostKeyChecking=no" \
			    "-p ${local_port}\";" \
			"alias sshfs=\"sshfs -p ${local_port}\";" \
			"alias scp=\"scp -P ${local_port}\"" \
			) || :
    export SHELLOPTS

    echo "Dropped connection to \"${1}\""
}




function usage ()
{
    echo "Usage: ${0} -- to be explained"
    exit
}

check_3d_party_setup

if [[ ${#} -eq 0 ]] ; then
    list_available_connections
elif [[ ${#} -eq 1 ]] ; then
    do_ssh ${1}
elif [[ ${#} -eq 2 ]] ; then
    if [[ (${1} == "-c") || (${1} == "--connect") ]] ; then
	do_connection_environment ${2}
    else
	usage
    fi
else
    usage
fi
